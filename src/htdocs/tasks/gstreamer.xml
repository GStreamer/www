<?xml-stylesheet href="tasks.xsl" type="text/xsl"?>
<page>
  <title>GStreamer: Tasks</title>
  <body>
  </body>

  <tasks title="List of GStreamer tasks">

<task name="686basicomega">
    <title>Make basicomega scheduler work with i686 glibc</title>
    <description>
One of the fastest schedulers we have is the one called basicomega.
Unfortunatly we have been bared from using it as the default for quite a
while because it segfaults when you use a version of glibc that has been
compiled with -march=686. This means that the standard glibc used with
major distributions like Mandrake and Red Hat cause this scheduler to crash.
    </description>

    <why>
Context switching is one of the tasks the scheduler does most. And the
faster the better. For many heavy applications being able to use this
scheduler would be a great boon.
    </why>

    <how>
If we knew we would have fixed it long ago ourselves.
Andy Wingo says the following:
<BR/>
"As you know, omega cothreads uses up the stack in pieces, one piece per
element. It assumes that it has 2M of stack space to work with, divided
into 16 pieces (see the top of cothreads.c). Now this 2M size is
arbitrary, and based on the old pre-i686 glibc's default stack size.
For new threads in gstthread.c, we explicitly ask for a 2M stack. But
for the main thread, we never try to query or even change the size with
getrlimit/setrlimit(2). I would suggest looking here for a solution (try
calling setrlimit(RLIMIT_STACK,rlim_struct_for_2M).
<br/>
So what might be happening is too many (more than 8) elements are being
put into the main thread and it's trying to use memory that doesn't
belong to it.Note also that the STACK_SIZE macro in cothreads.c and the 
STACK_SIZE macro in gstthread.c depend on each other.<br/>
Just keep in mind the saying about the worth of free advice :-)"
    </how>
    <where>
      <code id="basicomega">
        <name>Implementation of basicomega scheduler</name>
        <description>C file with the code for the scheduler</description>
      </code>
    
   </where>
   <difficulty>
HARD - Demands detailed knowledge of how glibc internals work and compiler optimizations.
    </difficulty>
    <see>
      <person>Andy</person>
      <person>David</person>
    </see>
  </task>
</tasks>
</page>

